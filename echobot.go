package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/nlopes/slack"
)

// Config file for slack api token and bot token
const (
	configJson = "/config/config.dev.json"
	MSG_LIMIT  = 950
)

// Data variables used throughout the package
// userMessages: map of user messages
// userIDs: map of userids that is generated by slack for its workspace users
// slackChannelIDS: slice of channel ids generated by slack for its workspace channels
// usernames: slice of usernames
// conf: the Config struct
var (
	userMessages    = make(map[string][]Message)
	userIDs         = make(map[string]string)
	slackChannelIDs []string
	usernames       []string
	conf            Config
)

// Config struct, holds your slack API tokens
type Config struct {
	//TODO: don't use all caps in Go names. goLint said so
	BOT_TOKEN string
	API_TOKEN string
}

// UserResponse struct for JSON encoding and decoding
type UserResponse struct {
	OK      bool     `json:"ok"`
	Members []Member `json:"members"`
}

// Channel response struct for JSON encoding and decoding
type ChannelResponse struct {
	OK       bool      `json:"ok"`
	Channels []Channel `json:"channels"`
}

// Channel struct holds data about the channel
type Channel struct {
	Id         string `json:"id"`
	Name       string `json:"name"`
	Created    int    `json:"created"`
	IsArchived bool   `json:"is_archived"`
	Creator    string `json:"creator"`
}

// Member type struct includes metadata about the user
type Member struct {
	ID       string `json:"id"`
	TeamID   string `json:"team_id"`
	Name     string `json:"name"`
	Color    string `json:"color"`
	RealName string `json:"real_name"`
	Profile  Profile
}

// Profile type struct for the user's data displayed on slack
type Profile struct {
	RealName      string `json:"real_name"`
	DisplayName   string `json:"display_name"`
	StatusText    string `json:"status_text"`
	StatusEmoji   string `json:"status_emoji"`
	ImageOriginal string `json:"image_original"`
	Email         string `json:"email"`
	FirstName     string `json:"first_name"`
	LastName      string `json:"last_name"`
}

// HistoryResponse struct for all the channel history messages
type HistoryResponse struct {
	Ok        bool      `json:"ok"`
	Messages  []Message `json:"messages"`
	HasMore   bool      `json:"has_more"`
	IsLimited bool      `json:"is_limited"`
}

// Message type struct representing the message json payload incoming from slack
type Message struct {
	Type        string     `json:"type"`
	Subtype     string     `json:"subtype"`
	User        string     `json:"user"`
	Text        string     `json:"text"`
	ClientMsgId string     `json:"client_msg_Id"`
	Ts          string     `json:"ts"`
	Reactions   []Reaction `json:"reactions"`
	File        File       `json:"file"`
}

// Reaction type struct representing the reaction payload coming from slack
type Reaction struct {
	Name  string   `json:"name"`
	Users []string `json:"users"`
	Count int      `json:"count"`
}

// File struct
type File struct {
	URLPrivate string `json:"url_private"`
}

// GenericResponse interface, with the filter method
type GenericResponse interface {
	filter(word string)
}

// Init function for initialization of the bot
// Gets config params
// Gets slice of users
// Set user messages and write to file
func init() {
	getConfig()
	getUsers()
	setUserMessages()
}

// Call the slack api to list all users in a slack team
// Check if the getResponse got error
// Set userIDs to actual names of the user in the slack team
func getUsers() {
	userResp := UserResponse{}
	userEndpoint := fmt.Sprintf("https://slack.com/api/users.list?token=%s&pretty=1", conf.API_TOKEN)

	getResponse(userEndpoint, &userResp)
	err := writeToFile("users", &userResp)

	check(err)
	setUserIDs(&userResp)
}

// Returns a users ID from the inputted user's name
func getUserIDs(name string) (userID string) {
	return userIDs[name]
}

// Calls the slack api to get list of all channels in the team and appends to the slackChannelIDs slice
// returns slice of slackChannelIDs
func getChannels() []string {
	channelResp := ChannelResponse{}
	channelEndpoint := fmt.Sprintf("https://slack.com/api/channels.list?token=%s&pretty=1", conf.API_TOKEN)

	getResponse(channelEndpoint, &channelResp)
	err := writeToFile("channels", &channelResp)
	check(err)

	if channelResp.OK {
		for _, c := range channelResp.Channels {
			slackChannelIDs = append(slackChannelIDs, c.Id)
		}
	}
	return slackChannelIDs
}

// Get the history of messages and events from a slack channel
// Clean the payload for messages that are calling echobot
func getChannelHistory(chanID string, h *HistoryResponse) {
	histEndpoint := fmt.Sprintf("https://slack.com/api/channels.history?token=%s&channel=%s&count=%d&pretty=1", conf.API_TOKEN, chanID, MSG_LIMIT)
	getResponse(histEndpoint, h)
	cleanEchobotMsg(h)
	err := writeToFile(chanID, h)
	check(err)
}

// Make the GET call for the urls, sets the response body to one of the response structs
func getResponse(url string, v interface{}) {
	resp, err := http.Get(url)
	defer resp.Body.Close()
	check(err)
	body, err := ioutil.ReadAll(resp.Body)
	err = json.Unmarshal(body, v)
	check(err)
}

// Gets the configuration params from the current working dir + the path defined for the config file in configJson
func getConfig() {
	dir, err := os.Getwd()
	check(err)
	c, err := ioutil.ReadFile(dir + configJson)
	check(err)
	err = json.Unmarshal([]byte(string(c)), &conf)
	check(err)
}

// Set the usernames from the users list response
func setUserIDs(u *UserResponse) {
	if u.OK {
		for _, c := range u.Members {
			name := strings.Split(c.Name, ".")[0]
			userIDs[name] = c.ID
			usernames = append(usernames, strings.ToLower(name))
		}
	}
}

// Filter the receiver type of HistoryResponse by the UserID and return a slice of messages by that User.
func (h *HistoryResponse) filterByUser(userID string) (result []Message) {
	for _, m := range h.Messages {
		if m.User == userID {
			if m.Subtype == "file_share" {
				m.Text = m.Text + " " + m.File.URLPrivate
			}
			result = append(result, m)
		}
	}
	return result
}

// Filter the receiver type of HistoryResponse by a string word
func (h *HistoryResponse) filter(word string) {
	for i, m := range h.Messages {
		if strings.Contains(m.Text, word) {
			num := i + 1
			if len(h.Messages) >= num {
				num = i
			}
			h.Messages = append(h.Messages[:i], h.Messages[num:]...)
		}
	}
}

// Write supplied string data type to file
func writeToFile(filename string, v interface{}) (err error) {
	str, err := json.MarshalIndent(v, "", "  ")
	check(err)
	dir, err := os.Getwd()
	check(err)
	file := fmt.Sprintf("%s/data/%s.json", dir, filename)
	err = ioutil.WriteFile(file, str, 0644)
	check(err)
	return err
}

// Filter out echobot messages from the channel history response
func cleanEchobotMsg(v GenericResponse) {
	v.filter(getUserIDs("echobot"))
}

// Gets the channel history messages sort by users and write to file:
// userIDs, userMessages and slackChannelIDs
func setUserMessages() {
	chanIDs := getChannels()

	for _, cID := range chanIDs {
		histResp := HistoryResponse{}
		getChannelHistory(cID, &histResp)

		for _, username := range usernames {
			uid := getUserIDs(username)
			result := histResp.filterByUser(uid)
			userMessages[username] = append(result, userMessages[username]...)
		}
	}

	writeToFile("userIDs", userIDs)
	writeToFile("userMessages", userMessages)
	writeToFile("slackChannelIDs", slackChannelIDs)
}

// Responds back to Slack Channel, grabs the name of user sent from the channel
// Grab a random message from the slic of userMessages for that user
// Send the message back to the slack channel
func respond(rtm *slack.RTM, msg *slack.MessageEvent, prefix string) {
	text := msg.Text
	text = strings.TrimPrefix(text, prefix)
	text = strings.TrimSpace(text)
	text = strings.ToLower(text)

	if userMessages[text] != nil {
		for i := 0; i < 3; i++ {
			length := len(userMessages[text])
			responseIndex := rand.Intn(length)
			str := strings.Split(userMessages[text][responseIndex].Text, " ")
			userMessages[text] = append(userMessages[text][:responseIndex], userMessages[text][responseIndex+1:]...)
			response := strings.Join(str, " ")
			rtm.SendMessage(rtm.NewOutgoingMessage(response, msg.Channel))
			time.Sleep(time.Duration(1) * time.Second)
		}
	}
}

func main() {
	api := slack.New(conf.BOT_TOKEN)
	rtm := api.NewRTM()
	go rtm.ManageConnection()

	// Label to break out of the loop when err
Loop:
	for {
		select {
		case msg := <-rtm.IncomingEvents:
			fmt.Print("-- Event Received: ")
			switch ev := msg.Data.(type) {
			case *slack.ConnectedEvent:
				fmt.Println("-- Connection counter:", ev.ConnectionCount)

			case *slack.MessageEvent:
				//fmt.Printf("-- Message: %v\n", ev)
				info := rtm.GetInfo()
				prefix := fmt.Sprintf("<@%s> ", info.User.ID)

				if ev.User != info.User.ID && strings.HasPrefix(ev.Text, prefix) {
					respond(rtm, ev, prefix)
				}

			case *slack.RTMError:
				fmt.Printf("-- Error: %s\n", ev.Error())

			case *slack.InvalidAuthEvent:
				fmt.Println("-- Invalid credentials")
				break Loop

			default:
				// Take no action
			}
		}
	}
}

func check(e error) {
	if e != nil {
		fmt.Printf("-- e = %v \n", e)
		panic(e)
	}
}
